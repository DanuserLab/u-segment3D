function importExternalData(movieData, processClass, varargin)
% importExternalData imports external results into the movie infrastructure
%
% Copies all the external data from the input structure into an output
% directory and register them as part of an external process.
%
%     importExternalData(movieData, processClass) runs the external process
%     specified by processClass on the input movie
%
%     importExternalData(movieData, processClass, paramsIn) also takes the
%     a structure with inputs for optional parameters as an input
%     The parameters should be stored as fields in the structure, with the
%     field names and possible values as described below
%
%   Possible Parameter Structure Field Names:
%       ('FieldName' -> possible values)
%
%       ('OutputDirectory' -> character string)
%       Optional. A character string specifying the directory to save the
%       external data to.
%
%       ('InputData' -> Positive integer scalar or vector)
%       Optional. A nChanx1 cell array containing the paths to the data
%       generated by the external process
%t  
% Sebastien Besson, Nov 2014
%
% Updated by Qiongjing (Jenny) Zou, Dec 2024
% 1. To accept image stack as external masks
% 2. Make sure the external masks have the same nFrames as the movie
% 3. Make sure the external masks are imread readable and binary
%
% Copyright (C) 2025, Danuser Lab - UTSouthwestern 
%
% This file is part of uSegment3D_Package.
% 
% uSegment3D_Package is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% uSegment3D_Package is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with uSegment3D_Package.  If not, see <http://www.gnu.org/licenses/>.
% 
% 

%% ----------- Input ----------- %%

%Check input
ip = inputParser;
ip.CaseSensitive = false;
ip.addRequired('movieData', @(x) isa(x,'MovieData'));
ip.addRequired('processClass',@ischar);
ip.addOptional('paramsIn',[], @isstruct);
ip.parse(movieData,processClass,varargin{:});
paramsIn=ip.Results.paramsIn;

%Get the indices of any previous dummy detection processes
iProc = movieData.getProcessIndex(processClass,1,0);

%If the process doesn't exist, create it
if isempty(iProc)
    processConstr = str2func(processClass);
    iProc = numel(movieData.processes_)+1;
    movieData.addProcess(processConstr(movieData,...
        movieData.outputDirectory_));
end
dummyProc = movieData.getProcess(iProc);

%Parse input, store in parameter structure
p = parseProcessParams(dummyProc,paramsIn);

%% --------------- Initialization ---------------%%

% Get channel paths and initialize process paths and output dirs
nChan = numel(movieData.channels_);

%
channelIndex = find(~cellfun(@isempty, p.InputData));
channelIndex = channelIndex(:)';

% Setup the  input directories
inFilePaths = cell(1,nChan);
for i = channelIndex
    assert(exist(p.InputData{i}, 'file') == 2 || ...
        exist(p.InputData{i}, 'dir') == 7);
    inFilePaths{1, i} = p.InputData{i};
end
dummyProc.setInFilePaths(inFilePaths);

% Setup the output directories
outFilePaths = cell(1,nChan);
mkClrDir(p.OutputDirectory);
for  i = channelIndex
    [~, name, ext] = fileparts(p.InputData{i});
    if isempty(ext) % when InputData is a directory
        chaniPath = fullfile(p.OutputDirectory, sprintf('ExternalMask_Chan%d', i));
        mkdir(chaniPath);
        % Check images in InPut path are single images or an image stack
        imageFiles = dir(fullfile(p.InputData{i}, '*.*'));
        imageFiles = imageFiles(~[imageFiles.isdir]); % Remove directories
        if ~isequal(numel(imageFiles), movieData.nFrames_)
            if numel(imageFiles) > 1
                error('For channel %d, the number of external masks does not match the number of frames in the movie, and it is not a single image stack either.', i);
            end
            % If is a stack image, convert and save to single images
            fprintf('Converting image stack in channel %d...\n', i);
            tifFilePath = fullfile(p.InputData{i}, imageFiles(1).name);
            try
                tifInfo = imfinfo(tifFilePath);
                if ~isequal(numel(tifInfo), movieData.nFrames_)
                    error('For channel %d, the number of external masks in the stack does not match the number of frames in the movie.', i);
                end
                for k = 1:numel(tifInfo)
                    img = imread(tifFilePath, k); % Read k-th frame
                    % Check if the image is binary
                    if numel(unique(img)) ~= 2
                        error('Image in folder %s is not a binary image.', p.InputData{i});
                    end
                    outputFileName = fullfile(chaniPath, sprintf('ExternalMask_%04d.tif', k));
                    imwrite(img, outputFileName);
                end
            catch ME
                fprintf('Error processing image stack masks in channel %d: %s\n', i, ME.message);
            end
        else
            % If single images, just check if the first frame is imread reable and binary.
            try
                firstImagePath = fullfile(p.InputData{i}, imageFiles(1).name);
                firstImage = imread(firstImagePath);
                % Check if the image is binary
                if numel(unique(firstImage)) ~= 2
                    error('The external masks are not binary images.');
                end
                copyfile(p.InputData{i}, chaniPath);
            catch ME
                fprintf('Error processing single image masks for channel %d: %s\n', i, ME.message);
            end
        end
        outFilePaths{1, i} = chaniPath;
    else
        % If the file has an extension, just copy the file - not sure
        % why it is written like this, this part seems not called, b/c
        % InputData need to be folder on GUI.
        copyfile(p.InputData{i}, p.OutputDirectory);
        outFilePaths{1,i} = fullfile(p.OutputDirectory, [name ext]);
    end
    
end
dummyProc.setOutFilePaths(outFilePaths);

disp('Finished importing external data!')
